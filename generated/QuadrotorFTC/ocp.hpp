// This file was automatically generated by autogenu-jupyter (https://github.com/ohtsukalab/autogenu-jupyter). 
// The autogenu-jupyter copyright holders make no ownership claim of its contents. 

#ifndef CGMRES__OCP_QUADROTORFTC_HPP_ 
#define CGMRES__OCP_QUADROTORFTC_HPP_ 
 
#define _USE_MATH_DEFINES

#include <cmath>
#include <array>
#include <iostream>

#include "cgmres/types.hpp"
#include "cgmres/detail/macros.hpp"

namespace cgmres {

/// 
/// @class OCP_QuadrotorFTC
/// @brief Definition of the optimal control problem (OCP) of QuadrotorFTC.
/// 
class OCP_QuadrotorFTC { 
public:
  ///
  /// @brief Dimension of the state. 
  ///
  static constexpr int nx = 13;
 
  ///
  /// @brief Dimension of the control input. 
  ///
  static constexpr int nu = 4;
 
  ///
  /// @brief Dimension of the equality constraints. 
  ///
  static constexpr int nc = 0;
 
  ///
  /// @brief Dimension of the Fischer-Burmeister function (already counded in nc). 
  ///
  static constexpr int nh = 0;
 
  ///
  /// @brief Dimension of the concatenation of the control input and equality constraints. 
  ///
  static constexpr int nuc = nu + nc;

  ///
  /// @brief Dimension of the bound constraints on the control input. 
  ///
  static constexpr int nub = 4;

  double m = 0.063;
  double g = 9.81;
  double J1 = 5.83e-05;
  double J2 = 7.17e-05;
  double J3 = 0.0001;
  double d3 = 0.001;
  double l = 0.0624;
  double k = 0.0731;
  double c1 = 0.0;

  std::array<double, 13> s = {5, 5, 50, 1, 1, 1, 0, 1, 1, 1, 0.1, 0.1, 0.1};
  std::array<double, 13> s_terminal = {5, 5, 50, 1, 1, 1, 0, 1, 1, 1, 0.1, 0.1, 0.1};
  std::array<double, 13> x_ref = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0};
  std::array<double, 4> r = {1, 1, 1, 1};
  std::array<double, 4> u_ref = {g*m/(c1 + 3), g*m/(c1 + 3), g*m/(c1 + 3), g*m/(c1 + 3)};

  static constexpr std::array<int, nub> ubound_indices = {0, 1, 2, 3};
  std::array<double, nub> umin = {0.0065, 0.0065, 0.0065, 0.0065};
  std::array<double, nub> umax = {0.3266, 0.3266, 0.3266, 0.3266};
  std::array<double, nub> dummy_weight = {100.0, 100.0, 100.0, 100.0};

  void disp(std::ostream& os) const {
    os << "OCP_QuadrotorFTC:" << std::endl;
    os << "  nx:  " << nx << std::endl;
    os << "  nu:  " << nu << std::endl;
    os << "  nc:  " << nc << std::endl;
    os << "  nh:  " << nh << std::endl;
    os << "  nuc: " << nuc << std::endl;
    os << "  nub: " << nub << std::endl;
    os << std::endl;
    os << "  m: " << m << std::endl;
    os << "  g: " << g << std::endl;
    os << "  J1: " << J1 << std::endl;
    os << "  J2: " << J2 << std::endl;
    os << "  J3: " << J3 << std::endl;
    os << "  d3: " << d3 << std::endl;
    os << "  l: " << l << std::endl;
    os << "  k: " << k << std::endl;
    os << "  c1: " << c1 << std::endl;
    os << std::endl;
    Eigen::IOFormat fmt(4, 0, ", ", "", "[", "]");
    Eigen::IOFormat intfmt(1, 0, ", ", "", "[", "]");
    os << "  s: " << Map<const VectorX>(s.data(), s.size()).transpose().format(fmt) << std::endl;
    os << "  s_terminal: " << Map<const VectorX>(s_terminal.data(), s_terminal.size()).transpose().format(fmt) << std::endl;
    os << "  x_ref: " << Map<const VectorX>(x_ref.data(), x_ref.size()).transpose().format(fmt) << std::endl;
    os << "  r: " << Map<const VectorX>(r.data(), r.size()).transpose().format(fmt) << std::endl;
    os << "  u_ref: " << Map<const VectorX>(u_ref.data(), u_ref.size()).transpose().format(fmt) << std::endl;
    os << std::endl;
    os << "  ubound_indices: " << Map<const VectorXi>(ubound_indices.data(), ubound_indices.size()).transpose().format(intfmt) << std::endl;
    os << "  umin: " << Map<const VectorX>(umin.data(), umin.size()).transpose().format(fmt) << std::endl;
    os << "  umax: " << Map<const VectorX>(umax.data(), umax.size()).transpose().format(fmt) << std::endl;
    os << "  dummy_weight: " << Map<const VectorX>(dummy_weight.data(), dummy_weight.size()).transpose().format(fmt) << std::endl;
  }

  friend std::ostream& operator<<(std::ostream& os, const OCP_QuadrotorFTC& ocp) { 
    ocp.disp(os);
    return os;
  }


  ///
  /// @brief Synchrozies the internal parameters of this OCP with the external references.
  /// This method is called at the beginning of each MPC update.
  ///
  void synchronize() {
  }

  ///
  /// @brief Computes the state equation dx = f(t, x, u).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[in] u Control input.
  /// @param[out] dx Evaluated value of the state equation.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_f(const double t, const double* x, const double* u, 
              double* dx) const {
    const double x0 = 2*x[6];
    const double x1 = 1.0/m;
    const double x2 = c1*u[0];
    const double x3 = u[1] + u[2] + u[3] + x2;
    const double x4 = x1*x3;
    const double x5 = (1.0/2.0)*x[10];
    const double x6 = (1.0/2.0)*x[8];
    const double x7 = (1.0/2.0)*x[9];
    const double x8 = (1.0/2.0)*x[11];
    const double x9 = (1.0/2.0)*x[12];
    const double x10 = x[11]*x[12];
    dx[0] = x[3];
    dx[1] = x[4];
    dx[2] = x[5];
    dx[3] = x4*(x0*x[8] + 2*x[7]*x[9]);
    dx[4] = x4*(-x0*x[7] + 2*x[8]*x[9]);
    dx[5] = -g + x1*x3*(pow(x[6], 2) - pow(x[7], 2) - pow(x[8], 2) + pow(x[9], 2));
    dx[6] = -x5*x[7] - x6*x[11] - x7*x[12];
    dx[7] = x5*x[6] + x6*x[12] - x7*x[11];
    dx[8] = x5*x[9] + x8*x[6] - x9*x[7];
    dx[9] = -x5*x[8] + x8*x[7] + x9*x[6];
    dx[10] = (J2*x10 - J3*x10 + l*u[1] - l*u[3])/J1;
    dx[11] = (-J1*x[10]*x[12] + J3*x[10]*x[12] + l*u[2] - l*x2)/J2;
    dx[12] = (J1*x[10]*x[11] - J2*x[10]*x[11] + c1*k*u[0] - d3*x[12] - k*u[1] + k*u[2] - k*u[3])/J3;
 
  }

  ///
  /// @brief Computes the partial derivative of terminal cost with respect to state, 
  /// i.e., phix = dphi/dx(t, x).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[out] phix Evaluated value of the partial derivative of terminal cost.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_phix(const double t, const double* x, double* phix) const {
    phix[0] = (1.0/2.0)*s_terminal[0]*(2*x[0] - 2*x_ref[0]);
    phix[1] = (1.0/2.0)*s_terminal[1]*(2*x[1] - 2*x_ref[1]);
    phix[2] = (1.0/2.0)*s_terminal[2]*(2*x[2] - 2*x_ref[2]);
    phix[3] = (1.0/2.0)*s_terminal[3]*(2*x[3] - 2*x_ref[3]);
    phix[4] = (1.0/2.0)*s_terminal[4]*(2*x[4] - 2*x_ref[4]);
    phix[5] = (1.0/2.0)*s_terminal[5]*(2*x[5] - 2*x_ref[5]);
    phix[6] = (1.0/2.0)*s_terminal[6]*(2*x[6] - 2*x_ref[6]);
    phix[7] = (1.0/2.0)*s_terminal[7]*(2*x[7] - 2*x_ref[7]);
    phix[8] = (1.0/2.0)*s_terminal[8]*(2*x[8] - 2*x_ref[8]);
    phix[9] = (1.0/2.0)*s_terminal[9]*(2*x[9] - 2*x_ref[9]);
    phix[10] = (1.0/2.0)*s_terminal[10]*(2*x[10] - 2*x_ref[10]);
    phix[11] = (1.0/2.0)*s_terminal[11]*(2*x[11] - 2*x_ref[11]);
    phix[12] = (1.0/2.0)*s_terminal[12]*(2*x[12] - 2*x_ref[12]);
 
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to state, 
  /// i.e., hx = dH/dx(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[in] u Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. 
  /// @param[in] lmd Costate. 
  /// @param[out] hx Evaluated value of the partial derivative of the Hamiltonian.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_hx(const double t, const double* x, const double* u, 
               const double* lmd, double* hx) const {
    const double x0 = (1.0/2.0)*x[10];
    const double x1 = (1.0/2.0)*x[11];
    const double x2 = (1.0/2.0)*x[12];
    const double x3 = 2*x[6];
    const double x4 = 2*x[8];
    const double x5 = 1.0/m;
    const double x6 = c1*u[0] + u[1] + u[2] + u[3];
    const double x7 = x5*x6;
    const double x8 = lmd[3]*x7;
    const double x9 = 2*x[7];
    const double x10 = lmd[4]*x7;
    const double x11 = lmd[5]*x7;
    const double x12 = 2*x[9];
    const double x13 = (1.0/2.0)*x[7];
    const double x14 = (1.0/2.0)*x[6];
    const double x15 = (1.0/2.0)*x[9];
    const double x16 = (1.0/2.0)*x[8];
    const double x17 = -J3*x[12];
    const double x18 = lmd[11]/J2;
    const double x19 = J2*x[11];
    const double x20 = lmd[12]/J3;
    const double x21 = lmd[10]/J1;
    const double x22 = J1*x[10];
    hx[0] = (1.0/2.0)*s[0]*(2*x[0] - 2*x_ref[0]);
    hx[1] = (1.0/2.0)*s[1]*(2*x[1] - 2*x_ref[1]);
    hx[2] = (1.0/2.0)*s[2]*(2*x[2] - 2*x_ref[2]);
    hx[3] = lmd[0] + (1.0/2.0)*s[3]*(2*x[3] - 2*x_ref[3]);
    hx[4] = lmd[1] + (1.0/2.0)*s[4]*(2*x[4] - 2*x_ref[4]);
    hx[5] = lmd[2] + (1.0/2.0)*s[5]*(2*x[5] - 2*x_ref[5]);
    hx[6] = lmd[7]*x0 + lmd[8]*x1 + lmd[9]*x2 + (1.0/2.0)*s[6]*(x3 - 2*x_ref[6]) - x10*x9 + x11*x3 + x4*x8;
    hx[7] = 2*lmd[3]*x5*x6*x[9] - lmd[6]*x0 - lmd[8]*x2 + (1.0/2.0)*lmd[9]*x[11] + (1.0/2.0)*s[7]*(x9 - 2*x_ref[7]) - x10*x3 - x11*x9;
    hx[8] = -lmd[6]*x1 + lmd[7]*x2 - lmd[9]*x0 + (1.0/2.0)*s[8]*(x4 - 2*x_ref[8]) + x10*x12 - x11*x4 + x3*x8;
    hx[9] = -lmd[6]*x2 - lmd[7]*x1 + lmd[8]*x0 + (1.0/2.0)*s[9]*(x12 - 2*x_ref[9]) + x10*x4 + x11*x12 + x8*x9;
    hx[10] = -lmd[6]*x13 + lmd[7]*x14 + lmd[8]*x15 - lmd[9]*x16 + (1.0/2.0)*s[10]*(2*x[10] - 2*x_ref[10]) + x18*(-J1*x[12] - x17) + x20*(J1*x[11] - x19);
    hx[11] = -lmd[6]*x16 - lmd[7]*x15 + lmd[8]*x14 + lmd[9]*x13 + (1.0/2.0)*s[11]*(2*x[11] - 2*x_ref[11]) + x20*(-J2*x[10] + x22) + x21*(J2*x[12] + x17);
    hx[12] = -d3*x20 - lmd[6]*x15 + lmd[7]*x16 - lmd[8]*x13 + lmd[9]*x14 + (1.0/2.0)*s[12]*(2*x[12] - 2*x_ref[12]) + x18*(J3*x[10] - x22) + x21*(-J3*x[11] + x19);
 
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to control input and the equality constraints, 
  /// i.e., hu = dH/du(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[in] u Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. 
  /// @param[in] lmd Costate. 
  /// @param[out] hu Evaluated value of the partial derivative of the Hamiltonian.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_hu(const double t, const double* x, const double* u, 
               const double* lmd, double* hu) const {
    const double x0 = k*lmd[12]/J3;
    const double x1 = l*lmd[11]/J2;
    const double x2 = 1.0/m;
    const double x3 = 2*x[6];
    const double x4 = lmd[3]*x2*(x3*x[8] + 2*x[7]*x[9]);
    const double x5 = lmd[4]*x2*(-x3*x[7] + 2*x[8]*x[9]);
    const double x6 = lmd[5]*x2*(pow(x[6], 2) - pow(x[7], 2) - pow(x[8], 2) + pow(x[9], 2));
    const double x7 = l*lmd[10]/J1;
    const double x8 = x4 + x5 + x6;
    const double x9 = -x0 + x8;
    hu[0] = c1*x0 - c1*x1 + c1*x4 + c1*x5 + c1*x6 + (1.0/2.0)*r[0]*(2*u[0] - 2*u_ref[0]);
    hu[1] = (1.0/2.0)*r[1]*(2*u[1] - 2*u_ref[1]) + x7 + x9;
    hu[2] = (1.0/2.0)*r[2]*(2*u[2] - 2*u_ref[2]) + x0 + x1 + x8;
    hu[3] = (1.0/2.0)*r[3]*(2*u[3] - 2*u_ref[3]) - x7 + x9;
 
  }

  ///
  /// @brief Computes the state equation dx = f(t, x, u).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[in] u Control input. Size must be nu.
  /// @param[out] dx Evaluated value of the state equation. Size must be nx.
  ///
  template <typename VectorType1, typename VectorType2, typename VectorType3>
  void eval_f(const double t, const MatrixBase<VectorType1>& x, 
              const MatrixBase<VectorType2>& u, 
              const MatrixBase<VectorType3>& dx) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (u.size() != nu) {
      throw std::invalid_argument("[OCP]: u.size() must be " + std::to_string(nu));
    }
    if (dx.size() != nx) {
      throw std::invalid_argument("[OCP]: dx.size() must be " + std::to_string(nx));
    }
    eval_f(t, x.derived().data(), u.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType3, dx).data());
  }

  ///
  /// @brief Computes the partial derivative of terminal cost with respect to state, 
  /// i.e., phix = dphi/dx(t, x).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[out] phix Evaluated value of the partial derivative of terminal cost. Size must be nx.
  ///
  template <typename VectorType1, typename VectorType2>
  void eval_phix(const double t, const MatrixBase<VectorType1>& x, 
                 const MatrixBase<VectorType2>& phix) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (phix.size() != nx) {
      throw std::invalid_argument("[OCP]: phix.size() must be " + std::to_string(nx));
    }
    eval_phix(t, x.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType2, phix).data());
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to the state, 
  /// i.e., hx = dH/dx(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[in] uc Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. Size must be nuc. 
  /// @param[in] lmd Costate.  Size must be nx.
  /// @param[out] hx Evaluated value of the partial derivative of the Hamiltonian. Size must be nx.
  ///
  template <typename VectorType1, typename VectorType2, typename VectorType3, typename VectorType4>
  void eval_hx(const double t, const MatrixBase<VectorType1>& x, 
               const MatrixBase<VectorType2>& uc, 
               const MatrixBase<VectorType3>& lmd, 
               const MatrixBase<VectorType4>& hx) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (uc.size() != nuc) {
      throw std::invalid_argument("[OCP]: uc.size() must be " + std::to_string(nuc));
    }
    if (lmd.size() != nx) {
      throw std::invalid_argument("[OCP]: lmd.size() must be " + std::to_string(nx));
    }
    if (hx.size() != nuc) {
      throw std::invalid_argument("[OCP]: hx.size() must be " + std::to_string(nx));
    }
    eval_hx(t, x.derived().data(), uc.derived().data(), lmd.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType4, hx).data());
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to control input and the equality constraints, 
  /// i.e., hu = dH/du(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[in] uc Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. Size must be nuc. 
  /// @param[in] lmd Costate. Size must be nx. 
  /// @param[out] hu Evaluated value of the partial derivative of the Hamiltonian. Size must be nuc.
  ///
  template <typename VectorType1, typename VectorType2, typename VectorType3, typename VectorType4>
  void eval_hu(const double t, const MatrixBase<VectorType1>& x, 
               const MatrixBase<VectorType2>& uc, 
               const MatrixBase<VectorType3>& lmd, 
               const MatrixBase<VectorType4>& hu) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (uc.size() != nuc) {
      throw std::invalid_argument("[OCP]: uc.size() must be " + std::to_string(nuc));
    }
    if (lmd.size() != nx) {
      throw std::invalid_argument("[OCP]: lmd.size() must be " + std::to_string(nx));
    }
    if (hu.size() != nuc) {
      throw std::invalid_argument("[OCP]: hu.size() must be " + std::to_string(nuc));
    }
    eval_hu(t, x.derived().data(), uc.derived().data(), lmd.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType4, hu).data());
  }

};

} // namespace cgmres

#endif // CGMRES_OCP_HPP_
